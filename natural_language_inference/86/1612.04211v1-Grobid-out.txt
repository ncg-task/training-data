title
Multi-Perspective Context Matching for Machine Comprehension
abstract
Previous machine comprehension (MC) datasets are either too small to train endto-end deep learning models, or not difficult enough to evaluate the ability of current MC techniques. The newly released SQuAD dataset alleviates these limitations, and gives us a chance to develop more realistic MC models. Based on this dataset, we propose a Multi-Perspective Context Matching (MPCM) model, which is an end-to-end system that directly predicts the answer beginning and ending points in a passage. Our model first adjusts each word-embedding vector in the passage by multiplying a relevancy weight computed against the question. Then, we encode the question and weighted passage by using bi-directional LSTMs. For each point in the passage, our model matches the context of this point against the encoded question from multiple perspectives and produces a matching vector. Given those matched vectors, we employ another bi-directional LSTM to aggregate all the information and predict the beginning and ending points. Experimental result on the test set of SQuAD shows that our model achieves a competitive result on the leaderboard.
To address the weakness of the previous MC datasets, Rajpurkar et al. (2016) developed the Stanford Question Answering dataset (SQuAD). Comparing with other datasets, SQuAD is more
Introduction
Machine Comprehension (MC) is a compelling yet challenging task in both natural language processing and artificial intelligent research. Its task is to enable machine to understand a given passage and then answer questions related to the passage.
In recent years, several benchmark datasets have been developed to measure and accelerate the progress of MC technologies. RCTest is one of the representative datasets. It consists of 500 fictional stories and 4 multiple choice questions per story (2,000 questions in total). A variety of MC methods were proposed based on this dataset. However, the limited size of this dataset prevents researchers from building end-to-end deep neural network models, and the state-of-the-art performances are still dominated by the methods highly relying on hand-crafted features or employing additional knowledge. To deal with the scarcity of large scale supervised data, proposed to create millions of Cloze style MC examples automatically from news articles on the CNN and Daily Mail websites. They observed that each news article has a number of bullet points, which summarise aspects of the information in the article. Therefore, they constructed a corpus of (passage, question, answer) triples by replacing one entity in these bullet points at a time with a placeholder. Then, the MC task is converted into filling the placeholder in the question with an entity within the corresponding passage. Based on this large-scale corpus, several end-to-end deep neural network models are proposed successfully realistic and challenging for several reasons: (1) it is almost two orders of magnitude larger than previous manually labeled datasets; (2) all the questions are human-written, instead of the automatically generated Cloze style questions; (3) the answer can bean arbitrary span within the passage, rather than a limited set of multiple choices or entities; (4) different forms of reasoning is required for answering these questions.
In this work, we focus on the SQuAD dataset and propose an end-to-end deep neural network model for machine comprehension. Our basic assumption is that a span in a passage is more likely to be the correct answer if the context of this span is very similar to the question. Based on this assumption, we design a Multi-Perspective Context Matching (MPCM) model to identify the answer span by matching the context of each point in the passage with the question from multiple perspectives. Instead of enumerating all the possible spans explicitly and ranking them, our model identifies the answer span by predicting the beginning and ending points individually with globally normalized probability distributions across the whole passage. Ablation studies show that all components in our MPCM model are crucial. Experimental result on the test set of SQuAD shows that our model achieves a competitive result on the leaderboard.
In following parts, we start with a brief definition of the MC task (Section 2), followed by the details of our MPCM model (Section 3). Then we evaluate our model on the SQuAD dataset (Section 4).

Task Definition
Generally, a MC instance involves a question, a passage containing the answer, and the correct answer span within the passage. To do well on this task, a MC model need to comprehend the question, reason among the passage, and then identify the answer span. demonstrates three examples from SQuAD. Formally, we can represent the SQuAD dataset as a set of tuples (Q, P, A), where Q = (q 1 , ..., q i , ..., q M ) is the question with a length M , P = (p 1 , ..., p j , ..., p N ) is the passage with a length N , and A = (a b , a e ) is the answer span, ab and a e are the beginning and ending points and 1 ? ab ? a e ? N . The MC task can be represented as estimating the conditional probability Pr (A|Q, P ) based on the training set, and  predicting answers for testing instances by
where A(P ) is a set of answer candidates from P . As the size of A(P ) is in the order of O(N 2 ), we make a simple independent assumption of predicting the beginning and endding points, and simplify the model as
where Pr(a b |Q, P ) (or Pr(a e |Q, P )) is the probability of the ab -th (or a e -th) position (point) of P to be the beginning (or ending) point of the answer span.

Multi-Perspective Context Matching Model
In this section, we propose a Multi-Perspective Context Matching (MPCM) model to estimate probability distributions Pr(a b |Q, P ) and Pr(a e |Q, P ). shows the architecture of our MPCM model. The predictions of Pr(a b |Q, P ) and Pr(a e |Q, P ) only differentiate at the last prediction layer. And all other layers below the prediction layer are shared.
Given a pair of question Q and passage P , the MPCM model estimates probability distributions through the following six layers.
Word Representation Layer. The goal of this layer is to represent each word in the question and passage with a d-dimensional vector. We construct the d-dimensional vector with two components: word embeddings and character-composed

Word Representation Layer
Filter Layer  embeddings. The word embedding is a fixed vector for each individual word, which is pre-trained with GloVe or word2vec. The character-composed embedding is calculated by feeding each character (also represented as a vector) within a word into a Long Short-Term Memory Network (LSTM). The output of this layer is word vector sequences for question Q : [q 1 , ..., q M ], and passage P : [p 1 , ..., p N ]. Filter Layer. In most cases, only a small piece of the passage is needed to answer the question (see examples in). Therefore, we define the filter layer to filter out redundant information from the passage. First, we calculate a relevancy degree r j for each word p j in passage P . Inspired from, we compute the relevancy degree r i,j between each word pair q i ? Q and p j ? P by calculating the cosine similarity

Context Representation Layer
, and get the relevancy degree by r j = max i?M r i,j . Second, we filter each word vector by p j = r j ? p j , and pass p j to the next layer. The main idea is that if a word in the passage is more relevant to the question, more information of the word should be considered in the subsequent steps.
Context Representation Layer. The purpose of this layer is to incorporate contextual informa-tion into the representation of each time step in the passage and the question. We utilize a bidirectional LSTM (BiLSTM) to encode contextual embeddings for each question word.
Meanwhile, we apply the same BiLSTM to the passage:
Multi-Perspective Context Matching Layer. This is the core layer within our MPCM model. The goal of this layer is to compare each contextual embedding of the passage with the question with multi-perspectives. We define those multiperspective matching functions in following two directions:
First, dimensional weighted matchings with
where v 1 and v 2 are two d-dimensional vectors, W ? l?d is a trainable parameter, l is the number of perspectives, and the returned value m is a l-dimensional vector m = [m 1 , ..., m k , ..., ml ]. Each element m k ? m is a matching value from the k-th perspective, and it is calculated by the cosine similarity between two weighted vectors
where ? is the elementwise multiplication, and W k is the k-th row of W , which controls the k-th perspective and assigns different weights to different dimensions of the d-dimensional space. Second, on the orthogonal direction off m , we define three matching strategies to compare each contextual embedding of the passage with the question:
(1) Full-Matching: each forward (or backward) contextual embedding of the passage is compared with the forward (or backward) representation of the entire question.
(2) Maxpooling-Matching: each forward (or backward) contextual embedding of the passage is compared with every forward (or backward) contextual embeddings of the question, and only the maximum value is retained.
(3) Meanpooling-Matching: This is similar to the Maxpooling-Matching, but we replace the max operation with the mean operation. For the examples in, the forward Full-Matching vector is extremely useful for question #1, because we only need to match the left context to the entire question. Similarly, the backward Full-Matching vector is very helpful for question #2. However, for question #3, we have to utilize the Maxpooling-Matching and Meanpooling-Matching strategies, because both the left and right contexts need to partially match the question.
Aggregation Layer. This layer is employed to aggregate the matching vectors, so that each time step of the passages can interactive with its surrounding positions. We incorporate the matching vectors with a BiLSTM, and generate the aggregation vector for each time step.
Prediction Layer. We predict the probability distributions of Pr(a b |Q, P ) and Pr(a e |Q, P ) separately with two different feed-forward neural networks (shown in, solid-lines for Pr(a b |Q, P ), dotted-lines for Pr(a e |Q, P )). We feed the aggregation vector of each time step into the feed-forward neural network individually, calculate a value for each time step, then normalize the values across the entire passage with sof tmax operation.

Experiments

Experiment Settings
We evaluate our model with the SQuAD dataset. This dataset includes 87,599 training instances, 10,570 validation instances, and a large hidden test set 1 . We process the corpus with the tokenizer from Stanford CorNLP . To evaluate the experimental results, we employ two metrics: Exact Match (EM) and F1 score.
To initialize the word embeddings in the word representation layer, we use the 300-dimensional GloVe word vectors pre-trained from the 840B Common Crawl corpus. For the out-of-vocabulary (OOV) words, we initialize the word embeddings randomly. We set the hidden size as 100 for all the LSTM layers, and set the number of perspectives l of our multiperspective matching function (Equation (5)) as 50. We apply dropout to every layers in, and set the dropout ratio as 0.2. To train the model, we minimize the cross entropy of the be-  ginning and end points, and use the ADAM optimizer to update parameters. We set the learning rate as 0.0001. For decoding, we enforce the endpoint is equal or greater than the beginning point.

Results on the Test Set

Influence of the Multi-Perspective Matching Function
In this sub-section, we study the influence of our multi-perspective matching function in Eq.(5). We built a baseline model vanilla-cosine by replacing Eq.(5) with the vanilla cosine similarity function. We also varied the number of perspectives l among {1, 10, 30, 50}, and kept the other options un-   changed. shows the performance on the dev set. We can see that, even if we only utilize one perspective, our multi-perspective matching function works better than the vanilla-cosine baseline. When increasing the number of perspectives, the performance improves significantly. Therefore, our multi-perspective matching function is really effective for matching vectors.

Layer Ablation
In this sub-section, we evaluate the effectiveness of various layers in our MPCM model. We built several layer ablation models by removing one layer at a time. For the Multi-Perspective Context Matching Layer, we cannot remove it entirely. Instead, we built three models (w/o Full-Matching, w/o Maxpooling-Matching, w/o Meanpooling-Matching) by eliminating each matching strategy individually. shows the performance of all ablation models and our full MPCM model on the dev set. We can see that removing any components from the MPCM model decreases the performance significantly. Among all the layers, the Aggregation Layer is the most crucial layer. Among all the matching strategies, Maxpooling-Matching has the biggest effect. who what is when how many what was which where what did in what what does what type what are why how much what do what kind how did what year how long in which what were what has what can F1 EM  how did what has what were why what did what do what can what was what does where what type which what is what are how much who how many what kind how long when in what in which what year (71) F1 EM: Performance for different question types.

Result Analysis
To better understand the behavior of our MPCM model, we conduct some analysis of the result on the dev set. shows the performance changes based on the answer length. We can see that the performance drops when the answer length increases, and the EM drops faster than the F1 score. The phenomenon reveals that longer answers are harder to find, and it is easier to find the approximate answer region than identify the precise boundaries. shows the performances of different types of questions. The numbers inside the brackets are the frequency of that question type on the dev set. We can see that the performances for "in which" questions are much higher than the others. The possible reason is that the temporal expressions are easier to detect for "when" and "what year" questions, and there is an explicit boundary word "in" for "in what" and "in which" questions. Our model works poorly for the "how did" question. Because "how did" questions usually require longer answers, and the answers could be any type of phrases. visualizes the probability distributions produced by our MPCM model for an example question from the dev set, where the upper subfigure is the probabilities for the beginning point and the lower one is the probabilities for the ending point. We can see that our model assigns most mass of the probability to the correct beginning and ending points.
To conduct the error analysis, we randomly select 50 incorrect questions from the dev set. We found that predictions for 16% questions are acceptable (even though they are not in the correct answer list) and 22% overlap with the correct answer. 14% of the questions require reasoning across multiple sentences, and most of the remaining questions require external knowledge or complex reasoning.

Related Work
Many deep learning based models were proposed since the release of the SQuAD dataset. Based on the method of identifying the answer spans, most of the models can be roughly categorized into the following two classes:
Chunking and Ranking. In this kind of methods, a list of candidate chunks (answers) are extracted firstly. Then, models are trained to rank the correct chunk to the top of the list. proposed to collect the candidate chunks from all constituents of parse trees, and designed some hand-crafted features to rank the chunks with logistic regression model ("Logistic Regression" in). However, over 20% of the questions do not have any correct answers within the candidate list. To increase the recall, extracted candidate chunks based on some part-of-speech patterns, which made over 90% of the questions answerable. Then, they employed an attention-based RNN model to rank all the chunks ("Dynamic Chunk Reader" in).   Boundary Identification. Instead of extracting a list of candidate answers, this kind of methods learns to identify the answer span directly. Generally, some kinds of question-aware representations are learnt for each time step of the passage, then the beginning and ending points are predict based on the representations. proposed a match-LSTM model to match the passage with the question, then the Pointer Network was utilized to select a list of positions from the passage as the final answer ("Match-LSTM (Sequence)" in). However, the returned positions are not guaranteed to be consecutive. They further modified the Pointer Network to only predict the beginning or ending points ("Match-LSTM (Boundary)" and "Match-LSTM with Bi-Ptr" in). introduced the Dynamic Coattention Network ("Dynamic Coattention" in). Their model first captured the interactions between the question and the passage with a co-attentive encoder, then a dynamic pointing decoder was used for predicting the beginning and ending points. proposed a similar model with. This model employed a bi-directional attention flow mechanism to achieve a question-aware context representations for the passage, then the beginning and ending points were predict based on the representations. Our model also belongs to this category. However, different from all the previous models, our model generates the question-aware representations by explicitly matching contextual embeddings of the passage with the question from multiple perspectives, and no lexical or word vector information is passed to the boundary identification layer.

Conclusion
In this work, we proposed the Multi-Perspective Context Matching (MPCM) model for machine comprehension task. Our model identifies the answer span by matching each time-step of the passage with the question from multiple perspectives, and predicts the beginning and ending points based on globally normalizing probability distributions. Ablation studies show that all aspects of matching inside the MPCM model are crucial. Experimental result on the test set of SQuAD shows that our model achieves a competitive result on the leaderboard.