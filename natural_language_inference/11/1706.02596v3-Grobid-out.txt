title
Dynamic Integration of Background Knowledge in Neural NLU Systems
abstract
Common-sense and background knowledge is required to understand natural language, but in most neural natural language understanding (NLU) systems, this knowledge must be acquired from training corpora during learning, and then it is static at test time. We introduce a new architecture for the dynamic integration of explicit background knowledge in NLU models. A general-purpose reading module reads background knowledge in the form of freetext statements (together with task-specific text inputs) and yields refined word representations to a task-specific NLU architecture that reprocesses the task inputs with these representations. Experiments on document question answering (DQA) and recognizing textual entailment (RTE) demonstrate the effectiveness and flexibility of the approach. Analysis shows that our model learns to exploit knowledge in a semantically appropriate way. Sungjin Ahn, Heeyoul Choi, Tanel P?rnamaa, and  Yoshua Bengio. 2016. A neural knowledge language model. arXiv .
Introduction
Understanding natural language depends crucially on common-sense and background knowledge, for example, knowledge about what concepts are expressed by the words being read, and what relations hold between these concepts (relational knowledge). As a simple illustration, if an agent needs to understand that the statement "King Farouk signed his abdication" is entailed by "King Farouk was exiled to France in 1952, after signing his resignation", it must know (among other things) that abdication means resignation of a king.
In most neural natural language understanding (NLU) systems, the requisite background knowl-edge is implicitly encoded in the models' parameters. That is, what background knowledge is present has been learned from task supervision and also by pre-training word embeddings (where distributional properties correlate with certain kinds of useful background knowledge, such as semantic relatedness). However, acquisition of background knowledge from static training corpora is limiting for two reasons. First, it is unreasonable to expect that all background knowledge that could be important for solving an NLU task can be extracted from a limited amount of training data. Second, as the world changes, the facts that may influence how a text is understood will likewise change. In short: building suitably large corpora to capture all relevant information, and keeping the corpus and derived models up to date with changes to the world would be impractical.
In this paper, we develop a new architecture for dynamically incorporating external background knowledge in NLU models. Rather than relying only on static knowledge implicitly present in the training data, supplementary knowledge is retrieved from external knowledge sources (in this paper, ConceptNet and Wikipedia) to assist with understanding text inputs. Since NLU systems must already read and understand text inputs, we assume that background knowledge will likewise be provided in text form ( ?2). The retrieved supplementary texts are read together with the task inputs by an initial reading module whose outputs are contextually refined word embeddings ( ?3). These refined embeddings are then used as input to a task-specific NLU architecture (any architecture that reads text as a sequence of word embeddings can be used here). The initial reading module and the task module are learnt jointly, end-to-end.
We experiment with several different datasets on the tasks of document question answering (DQA) and recognizing textual entailment evaluating the impact of our proposed solution with both basic task architectures and a sophisticated task architecture for RTE ( ?4). We find that our embedding refinement strategy is effective ( ?5). On four competitive benchmarks, we show that refinement helps. First, simply refining the embeddings just using the context (and no additional background information) can improve performance significantly, but adding background knowledge helps further. Our results are competitive with the best systems, achieving a new state of the art on the recent TriviaQA benchmarks. Our success on this task is especially noteworthy because the task-specific architecture is a simple reading architecture, in particular a single layer BiLSTM with a feed-forward neural network for span prediction. Finally, we provide an analysis demonstrating that our systems are able to exploit background knowledge in a semantically appropriate manner ( ?5.3). It includes, for instance, an experiment showing that our system is capable of making appropriate counterfactual inferences when provided with "alternative facts".

External Knowledge as Supplementary
Text Inputs
Knowledge resources make information that could potentially be useful for improving NLU available in a variety different formats, such as natural language text, (subject, predicate, object)triples, relational data bases, and other structured formats. Rather than tailoring our solution to a particular structured representation, we assume that all supplementary information either already exists in natural language statements (e.g., encyclopedias) or can easily be recoded as natural language. Furthermore, while mapping from unstructured to structured representations is hard, the inverse problem is easy. For example, given a triple (abdication, ISA, resignation) we can construct the free-text assertion "Abdication is a resignation." using simple rules. Finally, the freetext format means that knowledge that exists only in unstructured text form such as encyclopedic knowledge (e.g., Wikipedia) is usable by our system.
An important question that remains to be answered is: given some text that is to be understood, what supplementary knowledge should be incorporated? The retrieval and preparation of contextually relevant information from knowledge sources is a complex research topic by itself, and there are several statistical and more recently neural approaches as well as approaches based on reinforcement learning. Rather than learning both how to incorporate relevant information and which information is relevant, we use a heuristic retrieval mechanism ( ?4) and focus on the integration model.
In the next section, we turn to the question of how to leverage the retrieved supplementary knowledge (encoded as text) in a NLU system.

Refining Word Embeddings by Reading
Virtually every NLU task-from document classification to translation to question answeringshould in theory be able to benefit from supplementary knowledge. While one could develop custom architectures for each task so as to read supplementary inputs, we would like ours to augment any existing NLU task architectures with the ability to read relevant information with minimal effort. To realize this goal, we adopt the strategy of refining word embeddings; that is, we replace static word embeddings with embeddings thatare functions of the task inputs and any supplementary inputs. Word embeddings can be considered a simple form of key-value memory stores that, in our case, not only contain general-purpose knowledge (as in typical neural NLU systems) but also contextual information (including background knowledge). The use of word-embeddings as memory has the advantage that it is transparent to the task-architecture which kinds of embeddings (refined or unrefined) are used. Our incremental refinement process encodes input texts followed by updates on the word embedding matrix in multiple reading steps. Words are first represented non-contextually (i.e., standard word embeddings), which can be conceived of as the columns in an embedding matrix E 0 . At each progressive reading step ? 1, a new embedding matrix E is constructed by refining the embeddings from the previous step E ?1 using (userspecified) contextual information X for reading step , which is a set of natural language sequences (i.e., texts). An illustration of our incremental refinement strategy can be found in.
In the following, we define this procedure formally. We denote the hidden dimensionality of ...: Illustration of our context-dependent, refinement strategy for word representations on an example from the SNLI dataset comprising the premise (X 1 = {p}), hypothesis (X 2 = {q}) and additional external information inform of free-text assertions from ConceptNet (X 1 = A). Note that for the QA task there would be another stage that additionally integrates Wikipedia abstracts of answer candidates (X 4 = W, see ?4). The reading architecture constructs refinements of word representations incrementally (conceptually represented as columns in a series of embedding matrices) E are incrementally refined by reading the input text and textual renderings of relevant background knowledge before computing the representations used by the task model (in this figure, RTE). our model by n and a fully-connected layer by

Unrefined Word Embeddings (E 0 )
The first representation level consists of noncontextual word representations, that is, word representations that do not depend on any input; these can be conceived of as an embedding matrix E 0 whose columns are indexed by words in ? * . The non-contextual word representation e 0 w for a single word w is computed by using a gated combination of fixed, pre-trained word vectors e p w ? Rn with learned character-based embeddings e char w ? Rn . We compute e char w using a single-layer convolutional neural network with n convolutional filters of width 5 followed by a max-pooling operation overtime. The formal definition of this combination is given in Eq. 1. In order to compute contextually refined word embeddings E given prior representations E ?1 we assume a given set of texts X = {x 1 , x 2 , . . .} thatare to be read at refinement iteration . Each text xi is a sequence of word tokens. We embed all tokens of every xi using the embedding matrix from the previous layer, E ?1 . To each word, we concatenate a one-hot vector of length L with position set to 1, indicating which layer is currently being processed. 1 Stacking the vectors into a matrix, we obtain a X i ? R d?|x i | . This matrix is processed by a bidirectional recurrent neural network, a BiLSTM (Hochreiter and Schmidhuber, 1997) in this work. The resulting output is further projected toX i by a fully-connected layer with ReLU activation (Eq. 2).
To finally update the previous embedding e ?1 w of word w, we initially maxpool all representations of occurrences matching the lemma of win every x ? X resulting in? w (Eq. 3). Finally, we combine the previous representation e ?1 w with? w to form an updated representation e w via a gated addition. This lets the model determine how much to revise the previous embedding with the newly read information (Eq. 5).
Note that we soften the matching condition for w using lemmatization, 2 lemma(w), during the pooling operation of Eq. 3 because contextual information about certain words is usually independent of the current word form w they appear in. As a consequence, this minor linguistic preprocessing step allows for additional interaction between tokens of the same lemma.
Pooling over lemma-occurrences effectively connects different text passages (even across texts) thatare otherwise disconnected, mitigating the problems arising from long-distance dependencies. This is reminiscent of the (soft) attention mechanism used in reading comprehension models (e.g.,;). However, our setup is more general as it allows for the connection of multiple passages (via pooling) at once and is able to deal with multiple inputs which is necessary to make use of additional input texts such as relevant background knowledge.

Experimental Setup
We run experiments on four benchmarks for two standard NLU tasks: recognizing textual entailment (RTE) and document question answering (DQA). In the following we describe our experimental setup.
Task-specific Models Since we wish to assess the value of the proposed embedding refinement strategy, we focus on relatively simple task architectures. We use single-layer bidirectional LSTMs (BiLSTMs) as encoders of the inputs represented by the refined or unrefined embeddings with a task-specific, feed-forward network for the final prediction. Such models are general reading architectures. To demonstrate that our reading module can be integrated into arbitrary task architectures, we also add our refinement module to a reimplementation of a state of the art architecture for RTE called ESIM. We refer the interested reader to the ESIM paper for details of the model.
All models are trained end-to-end jointly with the refinement module using a dimensionality of n = 300 for all but the TriviaQA experiments for which we had to reduce n to 150 due to memory constraints. All baselines operate on the unrefined word embeddings E 0 described in ?3.1. For the DQA baseline system we add the lemma in-question feature (liq) suggested in. Implementation details for the BiL-STM task architectures, as well as training details, are available in Appendix A.

Question Answering
Table 1 presents our results on two question answering benchmarks. The results demonstrate that the introduction of the refinement module helps consistently, and further improvements come from using commonsense knowledge from Concept-6 Statistics were extracted from the DBpedia Anchor Text dataset (http://downloads.dbpedia.org/ 2016-10/core-i18n/en/anchor_text_en.ttl. bz2).

Recognizing Textual Entailment

Supplementary Knowledge Sources We use
ConceptNet 3 (Speer and Havasi, 2012), a freelyavailable, multi-lingual semantic network that originated from the Open Mind Common Sense project and incorporates selected knowledge from various other knowledge sources, such as Wiktionary, Open Multilingual WordNet, OpenCyc and DBpedia. It presents information in the form of relational triples. 4 Additionally, we exploit Wikipedia abstracts in our DQA experiments as described below.
ConceptNet Integration Here we describe the heuristic we use to obtain plausibly relevant supplementary knowledge for understanding a text pair (p, q) from ConceptNet. Our hypothesis is that relations that link words and phrases across p and q are likely to be most valuable. Because assertions a in ConceptNet come inform of (subject, predicate, object)-triples (s, r, o), we retrieve all assertions for which s appears in q and o appears in p, or vice versa. Because still too many such assertions might be retrieved for an instance, we rank all retrievals based on their respective subject and object. The ranking score we use is the inverse product of appearances of the subject and the object in the KB, that is score(a) = ( a I(s a = s a ) ? a I(o a = o a )) ?1 , where I denotes the indicator function. During training and evaluation we retain the top-k assertions, using k = 50 for DQA and k = 20 for RTE. Note that fewer or even no assertions might be retrieved for a particular instance during training and testing.
Wikipedia Integration Here we describe the heuristic we use to obtain plausibly relevant supplementary knowledge from Wikipedia. We wish to use Wikipedia abstracts 5 as an addi-tional knowledge source to gather more information about the top answer predictions of our DQA model. To this end, we let the system first predict the top-16 answer spans without any information from Wikipedia. For each answer candidate string, we collect abstracts for their 3 most frequently linked Wikipedia entries. 6 Using more than only the most frequently linked Wikipedia entry for a given answer string, lets us mitigate problems arising from polysemous entity names, although it does mean the refinement model needs to be selective in extracting relevant information. The refinement module additionally reads the initial 50 tokens of each retrieved Wikipedia abstract and computes the final predictions.
Refinement Order When employing our embedding-refinement strategy, we first read the document (p) followed by the question (q) in case of DQA, and the premise (p) followed by the hypothesis (q) for RTE, that is, X 1 = {p} and X 2 = {q}. Additional knowledge in the form of a set of assertions A is integrated after reading the task-specific input for both DQA and RTE, that is, X 3 = A. Finally, for DQA we additionally add Wikipedia abstracts as background knowledge as described previously, that is, X 4 = W. In preliminary experiments we found that the final performance is not significantly sensitive to the order of presentation so we decided to fix our order as defined above.

Results
This section presents results. We provide ablations for a total of 7 task-dataset-model combinations and compare our final results to other works on the most recent benchmark datasets for each task (TriviaQA and MultiNLI), demonstrating that our results are competitive, and in some cases, state of the art, even without sophisticated task architectures.

Model
SQuAD T-Wiki T-Web   Net (A). Wikipedia (W) yields further, significant improvements on TriviaQA, slightly outperforming the current state of the art model. This is especially noteworthy given the simplicity of our QA architecture (i.e., a single layer BiL-STM) compared to the previous SotA attained by. The development results on SQuAD 7 show the same pattern of improvement, but here the results are slightly worse than the model of Clark and Gardner, and they are way off from the current best-known results (currently at 87% F1); 8 however, our intention with these experiments is to show of the value that external knowledge and our refinement process can bring, not to compete with highly tuned task architectures on a single dataset.
Controlling for computation. One potential explanation for the improvement obtained using the We do not report test set results for SQuAD due to restrictions on code sharing. 8 https://rajpurkar.github.io/SQuAD-explorer/  refinement module is that we are enabling more computation over the information present in the inputs, that is, we are effectively using a deeper architecture. To test whether this might be the case, we also ran an experiment with a 2-layer BiLSTM (+liq). This setup exhibits similar computational complexity and number of parameters to BiLSTM + p + q. We found that the second layer did not improve performance, suggesting that pooling over word/lemma occurrences in a given context between layers, is a powerful, yet simple technique. shows the results of our RTE experiments. In general, the introduction of our refinement strategy almost always helps, both with and without external knowledge. When providing additional background knowledge from ConceptNet, our BiLSTM based models improve substantially, while the ESIM-based models improve only on the more difficult MultiNLI dataset. Compared to previously published state of the art systems, our models acquit themselves quite well on the MultiNLI benchmark, and competitively on the SNLI benchmark. In parallel to this work, Gong et al. (2017) developed a novel task-specific architecture for RTE that achieves slightly better performance on MultiNLI than our ESIM + p + q + A based models. 9 It draws attention to the fact that when using our knowledge-enhanced embed-ding module, on the MultiNLI, the basic BiLSTM task model outperforms the task-specific ESIM model, which is architecturally much more complex and designed specifically for the RTE task. We do find that there is little impact of using external knowledge on the RTE task with ESIM, although the refinement strategy helps using just p + q. A more detailed set of experiments reported in Appendix B shows that by impoverishing the amount of training data and information present in the GloVe embeddings, the positive impact of supplemental information becomes much more pronounced. These results suggest that ESIM is able to learn important background information from the large-scale datasets and from pretrained embeddings, but this can be supplemented when necessary. Nevertheless, both ESIM and our BiL-STM models when trained with knowledge from ConceptNet are sensitive to the semantics of the provided assertions as demonstrated in our analysis in ?5.3. We argue that this is a desirable side effect because it makes the predictions of our model more interpretable than those not trained with knowledge. Furthermore, increasing the coverage of assertions in ConceptNet would most likely yield improved performance even without retraining our models. Finally, we remark that despite careful tuning, our re-implementation of ESIM fails to match the 88% reported in Chen et al. (2017) by 0.8%; however, with MultiNLI, we find that our implementation of ESIM performs considerably better (by approximately 5%). The instability of the results suggests, as well as the failure of a custom RTEarchitecture to consistently perform well suggests that current SotA RTE models maybe overfit to the SNLI dataset.

Qualitative Analysis
Although our empirical results show our knowledge-incorporation approach improves performance, in this section we attempt to assess whether we are learning to use the provided knowledge in a semantically appropriate way.
RTE To test our models sensitivity towards the semantics of the assertions for recognizing textual entailment, we run an experiment in which we swap the synonym with the antonym predicate in the provided assertions during test time. We hypothesize that in many cases these two predicates are very important for predicting either contradic-tion or entailment. Indeed, there is a strong performance drop of about 10% on MultiNLI examples for both the BiLSTM and the ESIM model for which either a synonym or an antonym-assertion is present. This very large drop clearly shows that our models are sensitive to the semantics of the provided knowledge. Examples of prediction changes are presented in. They demonstrate that the system has learned to trust the presented assertions to the point that it will make appropriate counterfactual inferences-that is, the change in knowledge has caused the change in prediction. For the interested reader we provide additional RTE analysis results in Appendix C DQA The following is an example question from the TriviaQA dataset: Answer candidates (i.e., Denmark, Corfu, Greece, Vanuata) were obtained from the top predicted answer spans computed by our model excluding Wikipedia (i.e., BiLSTM + p + q + A). Their corresponding abstracts were retrieved from Wikipedia and then given to our model in a second pass (i.e., BiLSTM + p + q + A + W). In this example, the final best prediction of the model changes from Denmark to Corfu after integrating the abstracts (here, the abstract clearly states that Corfu is an island). We studied a total of 25 similar answer changes, 14 of which went from incorrect to correct, and 11 of which went from correct to incorrect. In 11 of the 14 corrections, obvious information is present in the Wikipedia abstracts that reinforced the correct answer. Where the system was confused by the answers (i.e., when the abstracts switched the production from correct to incorrect), no obvious information was present in 8 of the 11 cases, suggesting that the model had difficulty coping with unrelated background information. In 3 of the 11, plausibly relevant information was present in the abstract of the correct answer, yet the model still made the incorrect answer change.
The existence of counterfactual inferences in RTE and the tendency to use reinforcing informa-p:
His off-the-cuff style seems amateurish the net cost of operations.
but uh these guys   tion about candidate answers in DQA suggest that our knowledge incorporating strategy is exploiting heterogeneous knowledge sources in semantically sensible ways.

Related Work
The role of background knowledge in natural language understanding has long been remarked on, especially in the context of classical models of AI; however, it has only recently begun to play a role in neural network models of NLU. Previous efforts have focused on specific tasks or certain kinds of knowledge, whereas we take a step towards a more generalpurpose solution for the integration of heterogeneous knowledge for NLU systems by providing a simple, general-purpose reading architecture that can read background knowledge encoded in simple natural language statements, e.g., "abdication is a type of resignation". In the are a of visual question answering  (2017) incorporate information about word senses into their representations before solving the downstream NLU task, which is similar. We go one step further by seamlessly integrating all kinds of fine-grained assertions about concepts that might be relevant for the task at hand.
Another important aspect of our approach is the notion of dynamically updating wordrepresentations with contextual information. Tracking and updating concepts, entities or sentences with dynamic memories is a very active research direction. However, those works typically focus on particular tasks whereas our approach is taskagnostic and most importantly allows for the easy integration of external background knowledge. Important progress has also been made in creating pre-trained, contextualized token representations.

Conclusion
We have presented a novel reading architecture that allows for the dynamic integration of background knowledge into neural NLU models. Our solution, which is based on the incremental refinement of word representations by reading supplementary inputs, is flexible and can be used with virtually any existing NLU architecture that rely on word embeddings as input. Our results show that embedding refinement using both the system's text inputs, as well as supplementary text from external background knowledge can yield large improvements. In particular, we have shown that relatively simple task architectures (e.g., based on simple BiLSTM readers) can become competitive with state of the art, task-specific architectures when augmented with our reading architecture. Our analysis demonstrates that our model learns to exploit provided background knowledge in a semantically appropriate way.

A Implementation Details
All our models were trained with 3 different random seeds and the top performance is reported 10 . An overview of hyper-parameters used in our experiments can be found in. In the following we explain the detailed implementation of our two task-specific, baseline models.
We assume to have computed the contextually (un-)refined word representations depending on the setup and embedded our input sequences q = (q 1 , ..., q L Q ) and p = (p 1 , ..., p LP ) to Q ? R n?L Q and P ? R n?L P , respectively. The word representation update gate in Eq. 4 is initialized with a bias of 1 to refine representations only slightly in the beginning of training. In the following as before, we denote the hidden dimensionality of our model by n and a fully-connected layer by
A.1 Question Answering Encoding In the DQA task q refers to the question and p to the supporting text. For our baseline (i.e., BiLSTM + liq) we additionally concatenate a binary feature top and q indicating whether the corresponding token lemma appeared in the question. However, it is omitted in the following for the sake of brevity. At first we process both sequences by identical BiLSTMs in parallel (Eq. 6) followed by a linear projection and a tanh nonlinearity (Eq. 7) .
U ? R n?2n is initialized by [I; I] where I ? R n?n is the identity matrix.
Prediction Our prediction-or answer layer is similar to. We first compute a weighted, n-dimensional representationq of the processed questionQ (Eq. 8). Result variations were small, that is within less than a percentage point in all experiments.
The probability distributions p s /p e for the start/end location of the answer is computed by a 2-layer MLP with a ReLU activated, hidden layer s j as follows:
The model is trained to maximize the loglikelihood of the correct answer spans by computing the sum of the correct span probabilities p s (i) ? p e (k) for span (i, k) under our model (Eq. 9). During evaluation we extract the span (i, k) with the best score and maximum token length k ? i ? 16 for SQuAD and k ? i ? 8 for TriviaQA.
TriviaQA Properly training a QA system on TriviaQA is much more challenging than SQuAD because of the large document sizes and the use of multiple paragraphs. Therefore, we adopt the approach of Clark and Gardner (2017) who were the first to properly train neural QA models on Trivi-aQA. It relies on splitting documents and merging paragraphs up to a certain maximum token length (600 per paragraph in our experiments), and only retaining the top-k paragraphs (6 in our case) for prediction. Paragraphs are ranked using the tfidf cosine similarity between question and paragraph. To speedup training only 2 paragraphs out of the top 4/6 for the W eb/W ikipedia datasets were sampled. The only architectural difference for this multi-paragraph setup is that we encode multiple p for each question q and the softmax of Eq. 9 is taken over all tokens of all paragraphs instead of only a single paragraph. For further details, we refer the interested reader to Clark and Gardner (2017) who explain this process in more detail. For optimization we employed ADAM with a learning rate of 10 ?3 which was halved when performance dropped between checkpoint (ckpt) intervals. We use 300-dimensional wordembeddings from as pre-trained word embeddings in all experiments. For regularization we make use of dropout on the computed non-contextual word representations e w defined in ?3.1 with the same dropout mask for all words in a batch. For QA we additionally applied dropout on the projections computed in Eq. 7.

A.2 Recognizing Textual Entailment
Encoding Analogous to DQA we encode our input sequences by BiLSTMs, however, for RTE we use conditional encoding instead. Therefore, we initially process the embedded hypothesis Q by a BiLSTM and use the respective end states of the forward and backward LSTM as initial states for the forward and backward LSTM that processes the embedded premise P.
Prediction We concatenate the outputs of the forward and backward LSTMs processing the premise p, i.e., pf wt ;p bw t ? R 2n and run each of the resulting LP outputs through a fully-connected layer with ReLU activation (h t ) followed by a max-pooling operation overtime resulting in a hidden state h ? Rn . Finally, h is used to predict the RTE label as follows:
The probability of choosing category c ? {entailment, contradiction, neutral} is defined in Eq. 10. Finally, the model is trained to maximize the log-likelihood of the correct category label given probability distribution p.

B Reducing Training Data & Dimensionality of Pre-trained Word Embeddings
We find that there is only little impact when using external knowledge on the RTE task when using a more sophisticated task model such as ESIM. We hypothesize that the attention mechanisms within ESIM together with powerful, pre-trained word representations allow for the recovery of some important lexical relations when trained on a large dataset. It follows that by reducing the number of training data and impoverishing pre-trained word representations the impact of using external knowledge should become larger.
To test this hypothesis, we gradually impoverish pre-trained word embeddings by reducing their dimensionality with PCA while reducing the number of training instances at the same time. 11 Our joint data and dimensionality reduction results are presented in. They show that there is indeed a slightly larger benefit when employing background knowledge from ConcepNet (A) in the more impoverished settings with largest improvements when using around 10k examples and reduced dimensionality to 10. However, we observe that the biggest over all impact over the baseline ESIM model stems from our contextual refinement strategy (i.e., reading only the premise p and hypothesis q) which is especially pronounced for the 1k and 3k experiments. This highlights once more the usefulness of our refinement strategy even without the use of additional knowledge.

C Further Analysis of Knowledge Utilization in RTE
Is additional knowledge used? To verify whether and how our models make use of additional knowledge, we conducted several experiments. First, we evaluated models trained with knowledge on our tasks while not providing any knowledge at test time. This ablation drops performance by 3.7-3.9% accuracy on MultiNLI, and by 4% F1 on SQuAD. This indicates the model is refining the representations using the provided assertions in a useful way.
What knowledge is used? After establishing that our models are somehow sensitive to seman-: Development set results for MultiNLI (Matched + Mismatched) when reducing training data and embedding dimensionality with PCA. In parenthesis we report the relative differences to the respective result directly above.  tics we wanted to find out which type of knowledge is important for which task. For this analysis we exclude assertions including the most prominent predicates in our knowledge base individually when evaluating our models. The results are presented in. They demonstrate that the biggest performance drop in total (blue bars) stems from related to assertions. This very prominent predicate appears much more frequently than other assertions and helps connecting related parts of the 2 input sequences with each other. We believe that related to assertions offer benefits mainly from a modeling perspective by strongly connecting the input sequences with each other and thus bridging long-range dependencies similar to attention. Looking at the relative drops obtained by normalizing the performance differences on the actually affected examples (green) we find that our models depend highly on the presence of antonym and synonym assertions for all tasks as well as partially on is a and derived from assertions. This is an interesting finding which shows that the sensitivity of our models is selective wrt. the type of knowledge and task. The fact that the largest relative impact stems from antonyms is very interesting because it is known that such information is hard to capture with distributional semantics contained in pre-trained word embeddings.